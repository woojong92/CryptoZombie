# [크립토좀비](https://cryptozombies.io) Lesson6를 학습하면서 정리한 내용입니다. #

# 챕터 1: Web3.js 소개 #

## Web3.js가 뭔가요? ##

- 이더리움 네트워크는 노드로 구성되어 있고, 각 노드는 블록체인의 복사본을 가지고 있다.
- 만약 당신이 스마트 컨트랙트의 함수를 실행하고자 한다면, 이 노드들 중 하나에 질의를 보내 아래 내용을 전달해야 한다:

	1.  스마트 컨트랙트의 주소
	2. 	실행하고자 하는 함수, 그리고
	3. 	그 함수에 전달하고자 하는 변수들
	
- 이더리움 노드들은** JSON-RPC** 라고 불리는 언어로만 소통 할 수 있고, 이는 사람이 읽기는 불편하다.
- 컨트랙트의 함수를 실행하고 싶다고 질의를 보내는 것은 다음과 같다:

		// 그래... 이런 방법으로 모든 함수 호출을 잘 작성할 수 있길 빌겠네!
		// 오른쪽으로 스크롤하게 ==>
		{"jsonrpc":"2.0","method":"eth_sendTransaction","params":[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155","to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0","gasPrice":"0x9184e72a000","value":"0x9184e72a","data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}

- Web3.js는 이런 질의를 몰라도 되게 해준다. 
- 위의 질의문을 작성할 필요 없이, 코드에서 함수를 호출하는 것은 다음과 같다:
		
		CryptoZombies.methods.createRandomZombie("Vitalik Nakamoto 🤔")
		  .send({ from: "0xb60e8dd61c5d32be8058bb8eb970870f07233155", gas: "3000000" })

## 시작하기 ##

- 패키지 도구를 써서 Web3.js 추가하기
		
		// NPM을 사용할 때
		npm install web3
		
		// Yarn을 사용할 때
		yarn add web3
		
		// Bower를 사용할 때
		bower install web3
		
		// ...기타 등등.

- github에서 간략화된 .js파일을 다운로드하고 프로젝트에 포함하기:

		<script language="javascript" type="text/javascript" src="web3.min.js"></script>

# 챕터 2: Web3 프로바이더(Provider) #

- 이더리움은 똑같은 데이터의 복사본을 공유하는 _노드_들로 구성되어 있다.

- **Web3.js**에서 **Web3 프로바이더**를 설정하는 것은 우리 코드에 읽기와 쓰기를 처리하려면 어떤 노드와 통신을 해야 하는지 설정하는 것이다.

- 이는 전통적인 웹 앱에서 API 호출을 위해 원격 웹 서버의 URL을 설정하는 것과 같다.


## Infura ##

- **Infura**는 빠른 읽기를 위한 캐시 계층을 포함하는 다수의 이더리움 노드를 운영하는 서비스 이다.

- 접근을 위한 API를 무룔로 사용할 수 있으며, Infura를 프로바이더로 사용하면, 자신만의 이더리움을 설치하고 계속 유지할 필요 없이 이더리움 블록체인과 메세지를 확실히 주고 받을 수 있다.

- 다음과 같이 Web3에 Web3 프로바이더로 Infura를 쓰도록 설정할 수 있다:

		var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));

- 하지만, 많은 사용자들이 우리의 DApp을 사용할 것이기에 - 그리고 이 사용자들은 단순히 읽기만 하는 게 아니라 블록체인에 뭔가 쓰기도 할 것이기에 - 우리는 이 사용자들이 그들의 개인 키로 트랜잭션에 서명을 할 수 있도록 해야 할 것이다.


> 참고: 이더리움(그리고 일반적으로 블록체인)은 트랜잭션에 전자 서명을 하기 위해 공개/개인 키 쌍을 사용한다. 말하자면 전자 서명을 위해 엄청나게 안전한 비밀번호 같은 것이다. 이런 방식으로 내가 만약 블록체인에서 어떤 데이터를 변경하면, 나의 공개 키를 통해 내가 거기 서명을 한 사람이라고 증명할 수 있다 - 하지만 아무도 내 개인 키를 모르기 때문에, 내 트랜잭션을 누구도 위조할 수 없다.

- 우리의 앱 프론트엔드에서 사용자들의 개인 키를 관리하려 하는 것은 아마 좋은 생각이 아닐 것이다.

- 하지만 운이 좋게도 자네는 그렇게 할 필요가 없다 - 이를 대신 처리해주는 서비스가 이미 있다. 이중 가장 유명한 것은 **메타마스크(Metamask)**이다.

## 메타마스크(Metamask) ##

- 메타마스크는 사용자들이 이더리움 계정과 개인 키를 안전하게 관리할 수 있게 해주는 크롬과 파이어폭스의 브라우저 확장 프로그램이다. 그리고 해당 계정들을 써서 Web3.js를 사용하는 웹사이트들과 상호작용을 할 수 있도록 해준다(만약 자네가 이걸 써본 적이 없다면, 당신은 분명 이걸 설치해보고 싶을 것이다 - 그러면 자네의 브라우저에서 Web3가 작동하고, 이더리움 블록체인과 통신하는 어떤 웹사이트와도 상호작용을 할 수 있다!).

- 그리고 개발자로서, 사용자들이 웹 브라우저를 써서 웹사이트를 통해 자네의 DApp과 상호작용을 하길 원한다면(우리의 크립토좀비 게임에서 하듯이), 당신은 분명 자네 DApp을 메타마스크와 호환할 수 있게 하고 싶을 것이다.

> 참고: 메타마스크는 내부적으로 Infura의 서버를 Web3 프로바이더로 사용한다. - 하지만 사용자들에게 그들만의 Web3 프로바이더를 선택할 수 있는 옵션을 주기도 한다. 즉 메타마스크의 Web3 프로바이더를 사용하면, 사용자에게 선택권을 주는 것이기도 하면서 자네 앱에서 걱정할 거리를 하나 줄일 수 있다.

## 메타마스크의 Web3 프로바이더 사용하기 ##

- 메타마스크는 web3라는 전역 자바스크립트 객체를 통해 브라우저에 Web3 프로바이더를 주입한다. 그러니 자네 앱에서는 web3가 존재하는지 확인하고, 만약 존재한다면 web3.currentProvider를 프로바이더로서 사용하면 된다.

- 여기 메타마스크에서 제공하는 템플릿 코드가 있다. 사용자가 메타마스크를 설치했는지 확인하고 설치가 안 된 경우 우리 앱을 사용하려면 메타마스크를 설치해야 한다고 알려주는 것이다:

		window.addEventListener('load', function() {
		
		  // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
		  if (typeof web3 !== 'undefined') {
		    // Mist/MetaMask의 프로바이더 사용
		    web3js = new Web3(web3.currentProvider);
		  } else {
		    // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
		    // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
		  }
		
		  // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있다:
		  startApp()
		
		})

- 자네는 자네가 만드는 모든 앱에서 이 예제 코드를 사용할 수 있다. 사용자들이 자네 앱을 사용하려면 메타마스크를 사용하도록 하기 위해서 말이다.


> 참고: 메타마스크 말고도 사용자들이 쓸 수 있는 다른 개인 키 관리 프로그램도 있다. 미스트(Mist) 웹 브라우저 같은 것들이다. 하지만, 그것들도 모두 web3 변수를 주입하는 동일한 형태를 사용하네. 그러니 사용자들이 다른 프로그램을 쓰더라도 여기서 우리가 설명하는 방식으로 사용자의 Web3 프로바이더를 인식할 수 있을 것이다.

# 챕터 3: 컨트랙트와 대화하기 #

- Web3.js는 스마트 컨트랙트와 통신을 위해 컨트랙트의 주소와 ABI 를 필요로 한다.

## 컨트랙트 주소 ##
- 스마트 컨트랙트를 모두 작성한 후, 당신을 그걸 컴파일한 후 이더리움에 배포할 것이다. 배포는 다음 레슨에서 다룰 것이다. 이는 코드를 작성하는 것과는 꽤나 다른 절차이기 때문에, 순서를 바꿔 **Web3.js**를 먼저 다루기로 한 것이다.

- 컨트랙트를 배포한 후, 해당 컨트랙트는 영원히 존재하는, 이더리움 상에서 고정된 주소를 얻을 것이다. 레슨2를 상기해보면, 이더리움 메인넷에서 크립토키티의 주소는 **0x06012c8cf97BEaD5deAe237070F9587f8E7A266d**였다.

- 자네의 스마트 컨트랙트와 통신을 하기 위해 배포 후 이 주소를 복사해야 할 것이다.

## 컨트랙트 ABI ##

- 자네 컨트랙트와의 통신을 위해 **Web3.js**에서 필요로 하는 다른 하나는 바로 컨트랙트의 **ABI**이다.

- ABI는** Application Binary Interface**의 줄임말이다. 기본적으로 **JSON 형태**로 자네 컨트랙트의 메소드를 표현하는 것이다.  컨트랙트가 이해할 수 있도록 하려면 Web3.js가 어떤 형태로 함수 호출을 해야 하는지 알려주는 것이다.

- 이더리움에 배포하기 위해 컨트랙트를 컴파일할 때(레슨 7에서 다룰 내용)), 솔리디티 컴파일러가 자네에게 **ABI**를 줄 것이다. 그러니 컨트랙트 주소와 함께 이를 복사하여 저장해야 한다.

- 우리가 아직 배포를 다루지 않았기 때문에, 이번 레슨에서 내가 자네를 위해 ABI를 컴파일하여 **cryptozombies_abi.js**라는 파일의 **cryptoZombiesABI 변수**에 저장해 놓았다.

- **cryptozombies_abi.js**를 우리 프로젝트에 포함하면, 해당 변수를 사용하여 크립토좀비 **ABI**에 접근할 수 있을 것이네.

## Web3.js 컨트랙트 인스턴스화하기 ##

- 컨트랙트의 주소와 ABI를 얻고 나면, 다음과 같이 Web3에서 인스턴스화 할 수 있다:

		// myContract 인스턴스화
		var myContract = new web3js.eth.Contract(myABI, myContractAddress);


# 챕터 4: 컨트랙트 함수 호출하기 #

- Web3.js로 컨트랙트와 통신할 수 있다.
- Web3.js는 컨트랙트의 함수를 호출하기 위해 **call** 과 **send** 메소드를 가지고 있다.

## Call ##

- **call**은 **view**와 **pure**함수를 위해 사용한다. 로컬 노드에서만 실행하고, 블록체인에 트랜잭션을 만들지 않는다.


> 복습: **view**와 **pure** 함수는 읽기 전용이고 블록체인에서 상태를 변경하지 않는다. 가스를 전혀 소모하지 않고, 메타마스크에서 트랜잭션에 서명하라고 사용자에게 창을 띄우지도 않는다.

- **Web3.js**를 사용하여, 다음과 같이 123을 매개변수로 myMethod라는 이름의 함수를 call 할 수 있다.

		myContract.methods.myMethod(123).call()

## Send ##


- **send**는 트랜잭션을 만들고 블록체인 상의 데이터를 변경한다. **view**와 **pure**가 아닌 모든 함수에 대해 **send**를 사용한다.


> 참고: 트랜잭션을 send하는 것은 사용자에게 가스를 지불하도록 하고, 메타마스크에서 트랜잭션에 서명하라고 창을 띄울 것이다. Web3 프로바이더로 메타마스크를 사용할 때, send()를 호출하면 자동으로 이 모든 것이 이루어지고, 우리의 코드에 어떤 특별한 것도 추가할 필요가 없다. 

- Web3.js를 사용하여, 다음과 같이 123을 매개 변수로 myMethod라는 이름의 함수를 호출하는 트랜잭션을 send할 수 있다:

		myContract.methods.myMethod(123).send()

- 구문은 **call()**과 거의 똑같다.

## 좀비 데이터 받기 ##

- 우리는 좀비 배열을 public으로 만들었다:

		Zombie[] public zombies;

- 솔리디티에서, public으로 변수를 선언하면 자동으로 같은 이름의 **퍼블릭 "getter" 함수**를 만든다.  그러니 당신이 ID 15인 좀비를 찾길 원한다면, 변수를 함수인 것처럼 호출할 수 있다: zombies(15).

- 여기에 우리의 프론트엔드에서 좀비 ID를 받아 해당 좀비에 대해 컨트랙트에 질의를 보내고, 결과를 반환하는 자바스크립트 함수를 작성하는 방법이 있다:


> 참고: 이번 레슨에서 우리가 사용하는 모든 코드 예제들은 콜백 대신 Promise를 사용하는 Web3.js 1.0 버전을 사용하고 있다. 당신이 온라인에서 찾을 수 있는 다른 많은 튜토리얼들에서는 Web3.js의 이전 버전을 사용하고 있다. 1.0 버전에서 문법이 많이 바뀌었으니, 만약 자네가 다른 튜토리얼에서 코드를 복사해온다면 같은 버전을 사용하고 있는지 확인해봐라!

		function getZombieDetails(id) {
		  return cryptoZombies.methods.zombies(id).call()
		}
		
		// 함수를 호출하고 결과를 가지고 무언가를 처리:
		getZombieDetails(15)
		.then(function(result) {
		  console.log("Zombie 15: " + JSON.stringify(result));
		});

- cryptoZombies.methods.zombies(id).call()는 Web3 프로바이더와 통신하여 우리 컨트랙트의 Zombie[] public zombies에서 인덱스가 id인 좀비를 반환하도록 할 것이다.

- 이는 외부 서버로 API 호출을 하는 것처럼 **비동기**적으로 일어난다는 것을 알아둬라. 즉 Web3는 여기서 **Promise**를 반환한다(만약 자네가 자바스크립트 Promise에 익숙하지 않다면... 계속하기 전에 추가적인 숙제를 해야 할 때이군!).

- **Promise**가 만들어지면(이는 Web3 프로바이더로부터 응답을 받았다는 것을 의미한다) 우리 예제 코드는 **then** 문장을 실행하고, 여기서 result를 콘솔에 로그로 기록한다.

- result는 다음과 같이 생긴 자바스크립트 객체가 될 것이다:

		{
		  "name": "H4XF13LD MORRIS'S COOLER OLDER BROTHER",
		  "dna": "1337133713371337",
		  "level": "9999",
		  "readyTime": "1522498671",
		  "winCount": "999999999",
		  "lossCount": "0" // Obviously.
		}

- 이후 이 객체를 해석하기 위한 프론트엔드 로직을 만들어 의미 있는 방향으로 이 객체를 프론트엔드에 표시할 것이다.


# 챕터 5: 메타마스크 & 계정 #

- 스마트 컨트랙트와 상호작용을 할 수 있는 프론트엔드 코드를 성공적으로 작성했다.

- 이제 각 요소들을 하나로 합쳐나가자. 

- 우리 앱의 홈페이지에 사용자의 전체 좀비 군대를 보여주고 싶다고 가정해보자.

- 현재 사용자가 가지고 있는 모든 좀비들의 ID를 찾기 위해 우리는 분명 첫 번째로 **getZombiesByOwner(owner)** 함수를 사용해야 할 것이다.

- 하지만 우리의 솔리디티 컨트랙트는 owner에 솔리디티 address를 보내도록 되어 있다. 그렇다면 우리가 어떻게 우리 앱을 사용하는 사용자의 주소를 알 수 있겠는가?

## 메타마스크에서 사용자 계정 가져오기 ##

- 메타마스크는 확장 프로그램 안에서 사용자들이 다수의 계정을 관리할 수 있도록 해준다.

-우리는 주입되어 있는 web3 변수에 현재 활성화된 계정이 무엇인지 다음처럼 확인할 수 있다:

		var userAccount = web3.eth.accounts[0]

- 사용자가 언제든지 메타마스크에서 활성화된 계정을 바꿀 수 있기 때문에, 우리 앱은 이 변수의 값이 바뀌었는지 확인하기 위해 계속 감시를 하고 값이 바뀌면 그에 따라 UI를 업데이트해야 할 것이다. 

- 예를 들어, 사용자들의 홈페이지에서 그들의 좀비 군대를 표시하고 싶다면, 메타마스크에서 계정을 바꾸었을 때 바뀐 계정에 대한 좀비 군대를 보여주기 위해 페이지를 업데이트해야 할 것이다.

- 이를 위해 다음과 같이 **setInterval**을 쓸 수 있다:
		
		var accountInterval = setInterval(function() {
		  // 계정이 바뀌었는지 확인
		  if (web3.eth.accounts[0] !== userAccount) {
		    userAccount = web3.eth.accounts[0];
		    // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
		    updateInterface();
		  }
		}, 100);

- 여기서는 userAccount가 여전히 web3.eth.accounts[0]과 같은지 확인하기 위해 100밀리초마다 확인하고 있다(즉 사용자가 해당 계정을 활성화해놓았는지 확인하는 것이지). 그렇지 않다면, userAccount에 현재 활성화된 계정을 다시 할당하고, 화면을 업데이트하기 위한 함수를 호출하네.



# 챕터 6: 좀비 군대 보여주기 #

- 자네가 컨트랙트로부터 받은 데이터를 실제로 보여줄 수 없다면 이 튜토리얼은 완전하다고 할 수 없을 것이다.

- 하지만, 현실적으로 자네는 React나 Vue.js 같은 프론트엔드 프레임워크를 사용하고 싶을 수도 있다. 그것들이 프론트엔드 개발자로서의 자네의 삶을 훨씬 편하게 만들어주기 때문이다. 하지만 React 또는 Vue.js 를 다루는 것은 이 튜토리얼의 범주 밖에 있다. 
- 
- 그래서 CryptoZombies.io의 초점을 이더리움과 스마트 컨트랙트에 맞추기 위해, 우리는 jQuery를 이용한 간단한 예제를 통해 어떻게 자네가 스마트 컨트랙트에서 전달받은 데이터를 파싱하고 표현할 수 있을지 보여줄 것이다.

**좀비 데이터 보여주기 - 간단한 예제**

- 내가 먼저 우리 문서의 내용에 빈 **<div id="zombies"></div>**와 빈 **displayZombies** 함수를 추가해 놓았다.

- 지난 챕터에서 우리가 **startApp()** 내에서 **getZombiesByOwner**의 호출 결과를 써서 호출한 **displayZombies**를 상기해보라. 그 함수의 결과로 아래와 같이 생긴 좀비 ID 배열을 전달받을 수 있다:

		[0, 13, 47]

- 따라서 **displayZombies** 함수는 다음과 같은 것을 할 것이네:

	1. 먼저 이미 무언가가 **#zombies** div의 안에 들어 있다면 이 div의 내용을 비워라(이렇게 하면 사용자가 그들의 활성화된 MetaMask 계정을 변경하면 새로운 좀비 군대를 로딩하기 전에 기존의 것을 삭제할 것이다).

	2. 반복을 통해 각 **id**마다 **getZombieDetails(id)**를 호출해서 우리의 스마트 컨트랙트에서 좀비에 대한 모든 정보를 찾아라. 그리고서

	3. 화면에 표시하기 위해 HTML 템플릿에 좀비에 대한 정보를 집어넣고, 해당 템플릿을 **#zombies** div에 붙여넣어라.

- 여기서도 우린 기본 템플릿 엔진이 없는 **jQuery**를 이용하기 때문에, 보기 싫을 수 있지만, 다음의 간단한 예제처럼 각 좀비에 대한 정보를 출력할 수 있다:
		
		// 우리 컨트랙트에서 좀비 상세 정보를 찾아, `zombie` 객체 반환
		getZombieDetails(id)
		.then(function(zombie) {
		  // HTML에 변수를 넣기 위해 ES6의 "template literal" 사용
		  // 각각을 #zombies div에 붙여넣기
		  $("#zombies").append(`<div class="zombie">
		    <ul>
		      <li>Name: ${zombie.name}</li>
		      <li>DNA: ${zombie.dna}</li>
		      <li>Level: ${zombie.level}</li>
		      <li>Wins: ${zombie.winCount}</li>
		      <li>Losses: ${zombie.lossCount}</li>
		      <li>Ready Time: ${zombie.readyTime}</li>
		    </ul>
		  </div>`);
		});

## 좀비 스프라이트는 어떻게 표현하나요? ##

- 위 예제에서 우리는 DNA를 문자열로 간단히 표현해 보았다. 하지만 DApp에서는 이것을 이미지로 바꿔서 자네의 좀비를 표현하고 싶다.

- 우린 DNA 문자열을 부분 문자열로 나누고, 모든 2자리 숫자를 이미지에 대응시켜 아래와 같이 이 작업을 처리했었다:

		// 좀비의 머리를 표현하는 1-7의 정수 얻기
		var head = parseInt(zombie.dna.substring(0, 2)) % 7 + 1
		
		// 순차적인 파일 이름으로 7개의 머리 이미지를 가지고 있네:
		var headSrc = "../assets/zombieparts/head-" + head + ".png"

- 각 컴포넌트는 CSS의 절대 좌표 포지셔닝을 이용해 다른 이미지 위에 위치할 거다.

- 만약 자네가 우리의 정확한 구현을 보고싶다면, 좀비를 표현하기 위해 우리가 사용한 **Vue.js 컴포넌트 소스**를 공개해놓았네. 그건 여기에서 볼 수 있네.

- 하지만 저 파일에는 많은 코드가 포함되어 있기 때문에, 그건 튜토리얼의 범주 밖이라네. 우린 위에서 본 매우 간단한 **jQuery** 구현에 집중할 것이고, 좀 더 아름다운 표현은 자네에게 숙제로 남겨두겠네 😉.


# 챕터 7: 트랜잭션 보내기 #

- 우리의 UI는 사용자의 메타마스크 계정을 감지하고, 자동으로 좀비 군대를 홈페이지에 표현할 것이다.

- 이제 **send** 함수를 이용해 스마트 컨트랙트의 데이터를 변경하는 방법을 살펴보도록 하자.

- 이 함수에는 **call** 함수와는 꽤 다른 부분이 있다:

	1. 트랜잭션을 전송(**send**)하려면 함수를 호출한 사람의 **from** 주소가 필요하다(솔리디티 코드에서는 **msg.sender**가 될 것이네). 이는 우리 DApp의 사용자가 되어야 할 것이니, 메타마스크가 나타나 그들에게 서명을 하도록 할거다.

	2. 트랜잭션 전송(**send**)은 가스를 소모한다.

	3. 사용자가 트랜잭션 전송을 하고 난 후 실제로 블록체인에 적용될 때까지는 상당한 지연이 발생할 것이다. 트랜잭션이 블록에 포함될 때까지 기다려야 하는데, 이더리움의 평균 블록 시간이 15초이기 때문이지. 만약 이더리움에 보류 중인 거래가 많거나 사용자가 가스 가격을 지나치게 낮게 보낼 경우, 우리 트랜잭션이 블록에 포함되길 기다려야 하고, 이는 몇 분씩 걸릴 수 있다.

	그러니 이 코드의 **비동기적 특성**을 다루기 위한 로직이 필요하게 될 거다.

## 좀비 만들기 ##

- 이제 사용자가 호출할 우리 컨트랙트 내의 첫번째 함수를 예제로 살펴보겠네: **createRandomZombie.**

- 여기서 우리 컨트랙트의 솔리디티 코드를 다시 확인:
		
		function createRandomZombie(string _name) public {
		  require(ownerZombieCount[msg.sender] == 0);
		  uint randDna = _generateRandomDna(_name);
		  randDna = randDna - randDna % 100;
		  _createZombie(_name, randDna);
		}

- 다음은 메타마스크를 사용해 Web3.js에서 위 함수를 호출하는 방법의 예제:

		function createRandomZombie(name) {
		  // 시간이 꽤 걸릴 수 있으니, 트랜잭션이 보내졌다는 것을
		  // 유저가 알 수 있도록 UI를 업데이트해야 함
		  $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");
		  // 우리 컨트랙트에 전송하기:
		  return CryptoZombies.methods.createRandomZombie(name)
		  .send({ from: userAccount })
		  .on("receipt", function(receipt) {
		    $("#txStatus").text("Successfully created " + name + "!");
		    // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
		    getZombiesByOwner(userAccount).then(displayZombies);
		  })
		  .on("error", function(error) {
		    // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
		    $("#txStatus").text(error);
		  });
		}

- 위 함수는 우리의 Web3 프로바이더에게 트랜잭션을 전송(send)하고, 몇 가지 이벤트 리스너들을 연결한다:

	- **receipt**는 트랜잭션이 이더리움의 블록에 포함될 때, 즉 좀비가 생성되고 우리의 컨트랙트에 저장되었을 때 발생하게 된다.
	- **error**는 트랜잭션이 블럭에 포함되지 못했을 때, 예를 들어 사용자가 충분한 가스를 전송하지 않았을 때 발생하게 된다. 우리는 우리의 UI를 통해 사용자에게 트랜잭션이 전송되지 않았음을 알리고, 다시 시도할 수 있도록 할 것이다.


> 참고: 당신이 **send**를 호출할 때 **gas**와 **gasPrice**를 선택적으로 지정할 수 있다. **.send({ from: userAccount, gas: 3000000 })**와 같이 말이다. 만약 지정하지 않는다면, 메타마스크는 사용자가 이 값들을 선택할 수 있도록 할 것이다.




# 챕터 8: Payable 함수 호출하기 #

- **attack**, **changeName** 그리고 **changeDna**의 로직은 매우 비슷할 것이고, 이를 구현하는 것은 단순하니 우리는 이 레슨에서 그것들을 코딩하는 데에 시간을 소비하지 않을 것이다.

> 사실, 이 함수 호출에는 이미 많은 반복 로직이 있기 때문에, **리팩토링**을 해서 공통 코드를 자체 함수로 만드는 것이 합리적일 것이다 (그리고 **txStatus**에 표시될 **메세지에 템플릿** 시스템을 이용하라 - 우린 이미 Vue.js 같은 프레임워크를 사용하면 얼마나 더 깔끔해질 수 있는지 보고 있다!)

이제 Web3.js에서 특별한 처리가 필요한 다른 종류의 함수를 살펴보겠다 - 바로 **payable** 함수이지.

## 레벨업! ##

- **ZombieHelper**를 다시 생각해보면, 우린 사용자가 레벨업할 수 있는 곳에 payable 함수를 추가했었다:
		
		function levelUp(uint _zombieId) external payable {
		  require(msg.value == levelUpFee);
		  zombies[_zombieId].level++;
		}

- 함수를 이용해 이더를 보내는 방법은 간단하지만, 이더가 아니라 wei로 얼마를 보낼지 정해야 하는 제한이 있다.

## Wei란? ##

- **wei**는 이더의 가장 작은 하위 단위이며 - 하나의 이더는 10^18개의 wei이다.

- 이건 세기에는 너무 많다 - 하지만 운이 좋게도 Web3.js에는 이러한 작업을 해주는 변환 유틸리티가 있다.

		// 이렇게 하면 1 ETH를 Wei로 바꿀 것
		web3js.utils.toWei("1");

- 우리 DApp에서, 우리는 **levelUpFee = 0.001 ether**로 설정. 그러니 **levelup** 함수를 호출할 때, 아래의 코드를 써서 사용자가 **0.001** 이더를 보내게 할 수 있다.

		CryptoZombies.methods.levelUp(zombieId)
		.send({ from: userAccount, value: web3js.utils.toWei("0.001") })




# 챕터 9: 이벤트(Event) 구독하기 #

- Web3.js를 통해 컨트랙트와 상호작용 하는 것은 꽤 간단하다 - 한번 당신의 환경을 구축하고 나면, 함수를 호출하고 트랜잭션을 전송하는 것은 일반적인 웹 API와 크게 다르지 않다.

- 여기 우리가 다루고자 하는 것이 하나 더 있다 - 자네의 컨트랙트에서 이벤트를 구독하는 것이네.

## 새로운 좀비 수신하기 ##

- **zombiefactory.sol**을 다시 생각해보면, 새로운 좀비가 생성될 때마다 매번 호출되던 **NewZombie**라는 이벤트가 있었다:

		event NewZombie(uint zombieId, string name, uint dna);

- **Web3.js**에서 자네는 이벤트를 구독하여 해당 이벤트가 발생할 때마다 **Web3 프로바이더**가 자네의 코드 내의 어떠한 로직을 실행시키도록 할 수 있네:

		cryptoZombies.events.NewZombie()
		.on("data", function(event) {
		  let zombie = event.returnValues;
		  // `event.returnValue` 객체에서 이 이벤트의 세 가지 반환 값에 접근할 수 있다:
		  console.log("새로운 좀비가 태어났습니다!", zombie.zombieId, zombie.name, zombie.dna);
		}).on("error", console.error);

- **이건 DApp에서 어떤 좀비가 생성되든지 항상 알림을 보낼 거라는 걸 명심해라** - 현재 사용자의 좀비만이 아니라는 것이다. 현재 사용자가 만든 것에 대해서만 알림을 보내고 싶다면 어떻게 해야 하겠는가?

## **indexed** 사용하기 ##

- 이벤트를 필터링하고 현재 사용자와 연관된 변경만을 수신하기 위해, 우리의 ERC721을 구현할 때 **Transfer** 이벤트에서 했던 것처럼 우리의 솔리디티 컨트랙트에 **indexed** 키워드를 사용해야 한다.

		event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);

이 경우, **_from**과 **_to**가 **indexed** 되어 있기 때문에, 우리 프론트엔드의 이벤트 리스너에서 이들을 필터링할 수 있다:

		// `filter`를 사용해 `_to`가 `userAccount`와 같을 때만 코드를 실행
		cryptoZombies.events.Transfer({ filter: { _to: userAccount } })
		.on("data", function(event) {
		  let data = event.returnValues;
		  // 현재 사용자가 방금 좀비를 받았네!
		  // 해당 좀비를 보여줄 수 있도록 UI를 업데이트할 수 있도록 여기에 추가
		}).on("error", console.error);

- **event**와 **indexed** 영역을 사용하는 것은 당신의 컨트랙트에서 변화를 감지하고 프론트엔드에 반영할 수 있게 하는 **유용한 방법**이다.

## 지난 이벤트에 대해 질의하기 ##

- 우린 **getPastEvents**를 이용해 지난 이벤트들에 대해 질의를 하고, **fromBlock**과 **toBlock** 필터들을 이용해 이벤트 로그에 대한 시간 범위를 솔리디티에 전달할 수 있다(여기서 "block"은 이더리움 블록 번호를 나타낸다).
		
		cryptoZombies.getPastEvents("NewZombie", { fromBlock: 0, toBlock: "latest" })
		.then(function(events) {
		  // `events`는 우리가 위에서 했던 것처럼 반복 접근할 `event` 객체들의 배열.
		  // 이 코드는 생성된 모든 좀비의 목록을 우리가 받을 수 있게 할 것.
		});

- 위 메소드를 사용해서 시작 시간부터의 이벤트 로그들에 대해 질의를 할 수 있기 때문에, 이를 통해 흥미로운 사용 예시를 만들 수 있다: **이벤트를 저렴한 형태의 storage**로 사용하는 것이다.

- 다시 생각해보면, 데이터를 블록체인에 기록하는 것은 솔리디티에서 가장 비싼 비용을 지불하는 작업 중 하나였다. 하지만 이벤트를 이용하는 것은 가스 측면에서 훨씬 더 저렴하다.

- 여기서 **단점**이 되는 부분은 스마트 컨트랙트 자체 안에서는 이벤트를 읽을 수 없다는 것. 하지만 히스토리로 블록체인에 기록하여 앱의 프론트엔드에서 읽기를 원하는 데이터가 있다면, 이는 새겨놓아야 할 중요한 사용 예시이다.

- **예를 들어**, 우린 이것을 좀비 전투의 히스토리 기록용으로 사용할 수 있다 - 좀비가 다른 좀비를 공격할 때마다, 그리고 누군가 이길 때마다 우린 이벤트를 생성할 수 있다. 스마트 컨트랙트는 추후 결과를 계산할 때 이 데이터가 필요하지 않지만, 사용자들이 앱의 프론트엔드에서 찾아볼 수 있는 유용한 데이터이다.


## 직접 해보기 ##

- Transfer 이벤트를 감지할 수 있는 코드를 추가. 그리고 현재 사용자가 새로운 좀비를 받았을 떄 우리 앱의 UI를 업데이트.

- 우린 이 코드를 **startApp** 코드의 끝부분에 추가해야 한다. **이벤트 리스너**를 추가하기 전에 **cryptoZombies** 컨트랙트가 확실히 초기화될 수 있도록 하기 위해서이지.

	1. **startApp()**의 끝부분에 **crpytoZombies.events.Transfer**를 수신하는 위의 코드 블록을 복사/붙여넣기 하게.
	
	2. UI를 업데이트 해야 하는 부분에 **getZombiesByOwner(userAccount).then(displayZombies);**를 사용하게.



# 챕터 10: 마무리하기 #

## 다음 단계 ##

- 이번 레슨은 일부러 기초적인 것을 다뤘네. 우리는 자네에게 스마트 컨트랙트와 상호작용 할 때 필요한 핵심 로직을 보여주고 싶었네. 하지만 코드에서 Web3.js 부분은 꽤 반복적인 게 많기 때문에 전체 구현을 하는 데에 너무 많은 시간을 쓰고 싶지는 않았네. 이번 레슨을 더 길게 만들어 다른 새로운 개념을 소개하지도 않을 것이네.

- 그러니 이런 구현은 기초적인 것으로 놔두고, 우리 좀비 게임 프론트엔드의 완전한 구현을 위해 생각해볼 것들의 체크리스트를 알려주겠네. 자네가 이걸 자네만의 것으로 만들어보고 싶다면:

	1. attack, changeName, changeDna, 그리고 ERC721 함수인 transfer, ownerOf, balanceOf 함수를 구현하게. 이런 함수들의 구현은 우리가 다룬 모든 다른 send 트랜잭션과 동일할 것이네.
	
	2. 자네가 setKittyContractAddress, setLevelUpFee, 그리고 withdraw를 실행할 수 있는 "관리 페이지"를 구현하게. 다시 한번 말하지만, 프론트엔드에 더 특별한 로직은 없네 - 이러한 구현들은 우리가 이미 다룬 함수들과 동일할 것이네. 자네는 그저 해당 컨트랙트를 배포했던 이더리움 주소에서 이 함수들을 호출했는지 확인하면 되네. 이 함수들은 onlyOwner 제어자를 가지고 있으니 말이야.
	
	3. 이 앱에서 구현하고 싶은 다른 몇 가지 화면이 있을 수 있네:
	
		a. 개별 좀비 페이지: 특정 좀비에 대한 영구적인 링크를 통해 그 좀비의 정보를 볼 수 있는 곳이지. 이 페이지에서는 좀비의 외관과 이름, 주인(사용자 프로필 페이지에 대한 링크와 함께), 승리/패배 횟수, 전투 기록, 기타 등등을 보여줄 것이네.
	
		b. 사용자 페이지: 영구적인 링크를 통해 사용자의 좀비 군대를 볼 수 있는 곳이지. 개별 좀비를 클릭하여 해당 페이지를 볼 수 있을 것이고, 자네가 메타마스크에 로그인되어 있고, 군대를 가지고 있다면 좀비를 클릭해 공격할 수도 있을 것이네.
	
		c. 홈페이지: 현재 사용자의 좀비 군대를 볼 수 있는, 사용자 페이지의 한 종류이지(우리가 index.html에서 구현학 시작헀던 곳이네).
	
	4. UI 상에서 사용자가 크립토키티를 먹이로 줄 수 있는 방법이 있어야 하겠지. 홈페이지에서 각 좀비 옆에 "먹이 주기" 같은 버튼을 만들고, 사용자가 고양이의 ID를 입력하게 하는 텍스트 박스를 만들 수 있겠지(또는 그 고양이의 URL, 예를 들면: https://www.cryptokitties.co/kitty/578397). 이 버튼은 feedOnKitty 함수를 호출할 것이네.
	
	5. UI 상에서 한 사용자가 다른 사용자의 좀비를 공격할 수 있는 방법이 있어야 할 것이네.
	
		이를 구현하는 하나의 방법은 한 사용자가 다른 사용자의 페이지로 들어가면, "이 좀비 공격하기" 버튼을 보여주는 것이네. 사용자가 그 버튼을 클릭하면, 현재 사용자의 좀비 군대를 포함하는 모달 창을 띄우고 "어떤 좀비로 공격하시겠습니까?" 메세지를 보여주면 되네.
	
		또 사용자의 홈페이지에서 각 좀비 옆에 "좀비 공격하기" 버튼을 둘 수도 있네. 사용자가 그걸 클릭하면, 사용자가 좀비의 ID를 입력하여 찾을 수 있는 찾기 영역을 가지는 모달 창을 띄울 수 있겠지. 또는 "아무 좀비나 공격하기" 같은 옵션을 줘서 임의로 찾을 수도 있을 것이네.
	
		그리고 쿨다운 기간이 아직 다 지나지 않은 사용자의 좀비는 회색 처리를 할 수도 있겠지. UI 상에서 사용자에게 해당 좀비로는 아직 공격할 수 없고 얼마나 더 기다려야 하는지 보여줄 수 있도록 말이야.
	
	6. 사용자의 홈페이지에는 각 좀비의 이름 또는 DNA를 바꾸고, 일정 비용을 내고 레벨업을 할 수 있는 옵션이 있을 수 있네. 사용자의 레벨이 충분하지 않으면 어떤 옵션들을 회색 처리를 할 수 있곘지.
	
	7. 새로운 사용자들을 위해, createRandomZombie()를 호출해 군대의 첫 번째 좀비를 만들 수 있는 입력 창과 함께 환영 메세지를 보여줄 수 있네.
	
	8. 마지막 챕터에서 논의한 것처럼, 우리 스마트 컨트랙트에 indexed 프로퍼티로 사용자의 address를 가지는 Attack 이벤트를 추가하고 싶을 수 있네. 이를 통해 실시간 알림을 만들 수 있을 것이네 - 사용자에게 그의 좀비가 공격당하면 알림 창을 띄워 알려주어, 그를 공격한 사용자/좀비를 보여주고 복수할 수 있게 하는 것이지.
	
	9. 또한 일종의 프론트엔드 캐시 계층을 구현하여 똑같은 데이터를 위해 Infura에 계속 접근하지는 않도록 하고 싶을 수 있네(우리의 현재 displayZombies 구현은 인터페이스를 새로고침할 때마다 각 좀비에 대해 getZombieDetails를 호출하지 - 하지만 현실적으로 우리의 군대에 추가된 새 좀비에 대해서만 이 함수를 호출하면 되네).
	
	10. 실시간 채팅방을 만들어 자네가 다른 사용자들의 군대를 부술 때마다 그 사용자를 도발할 수 있도록 하는 것? 제발 만들어 주게...
	
	- 이건 시작일 뿐이네 - 우리는 더 많은 기능들을 생각해낼 수 있을 것이야 - 그리고 이미 많은 목록을 만들었지.
	
	- 이런 전체 인터페이스를 만드는 데에는 많은 프론트엔드 코드를 써야 할 것이기에(HTML, CSS, 자바스크립트, 그리고 React나 Vue.js 같은 프레임워크), 이런 전체 프론트엔드를 만드는 것은 이것만으로 10개 레슨으로 전체 코스를 만들어야 할 것이야. 그러니 이 엄청난 구현은 자네에게 맡기겠네.



> 참고: 우리 스마트 컨트랙트는 분산화되어 있지만, 우리 DApp과 상호작용 할 수 있는 이 프론트엔드는 어딘가의 웹 서버에 완전히 중앙화되어 있을 것이네.
> 하지만, 우리가 Loom Network에서 만들고 있는 SDK를 쓰면, 중앙화된 웹 서버 대신 곧 자신만의 DAppChain에서 프론트엔드를 제공할 수 있을 것이네. 이더리움과 Loom DAppChain 간의 저런 방식으로, 전체 앱이 100% 블록체인 상에서 돌아갈 것이네.

## 결론 ##

- 이것으로 레슨 6이 끝났네. 이제 자네는 스마트 컨트랙트를 작성하고 사용자가 이와 통신할 수 있게 하는 프론트엔드를 만드는 모든 기술을 배웠네!

- 다음 레슨에서는, 이 퍼즐에서 마지막 잃어버린 조각을 다룰 것이네 - 스마트 컨트랙트를 이더리움에 배포하는 것이지.

- "다음 챕터"를 클릭하여 보상을 받도록 하게!





























































